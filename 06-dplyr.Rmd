# Tidyverse: dplyr {#seminar06}

```{r message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
```


Now that you understand vectors, tables, functions, and pipes, we can start with data analysis and Tidyverse way of doing it in earnest. 

## Tidyverse philosophy
Data analysis is different from "normal" programming as it mostly involves a series of sequential operations on the same table. You might load the table, transform some variables, filter data, select smaller subset of columns, aggregate by summarizing across different groups of variables before plotting it or formally analyzing it via statistical tests. Tidyverse is built around this serial nature of data analysis of piping a table through a chain of functions. Accordingly, Tidyverse functions take a _table_ (`data.frame` or `tibble`) as their _first_ parameter, which makes piping simpler, and return a _modified table_ as an output. This _table-in â†’ table-out_ consistency makes it easy to pipe these operations one after another. For me, it helps to think about Tidyverse functions as _verbs_: Actions that I perform on the table at each step. 

Here is quick teaser of how such sequential piping works. Below, we will examine each verb/function separately and I will also show you how same operations can be carried out using base R. Note that I put each verb/function on a separate line. This makes it easier to understand how many different operations you perform (number of lines), how complex they are (how long individuals lines of code are), and makes them easy to line-by-line. 

```{r}
mpg2lpk <- 2.82481061

mpg %>%
  # we filter the table by rows, 
  # only keeping rows for which year is 2008
  filter(year == 2008) %>%
  
  # we change cty and hwy columns by turning
  # miles/gallon into liters/kilometer
  mutate(cty = cty / mpg2lpk,
         hwy = hwy / mpg2lpk) %>%
  
  # we create a new column by computing an 
  # average efficiency as mean between city and highway cycles
  mutate(avg_mpg = (cty + hwy) / 2) %>%
  
  # we reduce the table to only two columns
  # class (of car) and avg_mpg
  select(class, avg_mpg) %>%
  
  # we group by each class of car
  # and compute average efficiency for each group (class of car)
  group_by(class) %>%
  summarise(class_avg_mpg = mean(avg_mpg), .groups="drop") %>%
  
  # we sort table rows to go from worst to best on efficiency
  arrange(class_avg_mpg) %>%
  
  # we kable (Knit the tABLE) to make it look nicer in the document
  knitr::kable()
```
## dplyr {#dplyr}
All functions discussed below are part of [dplyr](https://dplyr.tidyverse.org/)^[The name should invoke an image of data pliers. According to Hadley Wickham, you can pronounce it any way you like.] "grammar of data manipulation" package.

## `select()` columns by name {#select}
[Select](https://dplyr.tidyverse.org/reference/select.html) verb allows you to select/pick columns in a table using their names. This is very similar to using columns names for indexing tables you have learned in [seminar 3](#table-indexing). 

First, let us make a shorter version of `mpg` table by keeping only the first five rows. Note that you can also pick first N rows via [head()](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/head.html) function.
```{r}
short_mpg <- mpg[1:5, ]

# same "first five rows" but via head() function
short_mpg <- head(mpg, 5)

knitr::kable(short_mpg)
```

Here is how you can select only `model` and `cty` columns via square brackets notation 
```r
short_mpg[, c("model", "cty")] 
```
```{r echo=FALSE}
short_mpg[, c("model", "cty")] %>%
  knitr::kable()
```
And here how it is done via `select()`, note the lack of quotes around the names! 
```r
short_mpg %>%
  select(model, cty)
```
```{r echo=FALSE}
short_mpg %>%
  select(model, cty) %>%
  knitr::kable()
```

The idea of Tidyverse functions is to adopt to you, so you _can_ use quotes or pass a vector of strings with column names. All calls below produce the same effect, so pick the style you prefer (mine, is in the code _above_) and stick to it^[In general, bad but consistent styling is better than an inconsistent mix of good styles.].
```r
short_mpg %>%
  select(c("model", "cty"))
  
short_mpg %>%
  select("model", "cty")
  
short_mpg %>%
  select(c(model, cty))
```

As you surely remember, you can use negation to select _other_ indexes within a vector (`c(4, 5, 6)[-2]` gives you `[4, 6]`). For single bracket notation this mechanism does not work with column _names_ (only with their indexes). However, `select` has you covered, so we can select everything _but_ `cty` and `model`
```r
short_mpg %>%
  select(-cty, -model)
```
```{r echo=FALSE}
short_mpg %>%
  select(-cty, -model) %>%
  knitr::kable()
```
In the current version of `dplyr`, you can do the same negation via `!` (a `logical not` operator, you will meet later), moreover, it is now a recommended way of writing the selection^[At least, `-` is not mentioned anymore, even though it still works.]. The `-` and `!` are not synonyms and the difference is subtle but important, see below.
```r
# will produce the same result as above
short_mpg %>%
  select(!cty, !model)
```

As with the direct selection above, you can use negation with names as strings, you can negate a vector of names, etc. Again, it is mostly a matter of taste with consistency being more important than a specific choice you make.
```r
# will produce the same result as above
short_mpg %>%
  select(!c("cty", "model"))

short_mpg %>%
  select(!"cty", !"model"))
  
short_mpg %>%
  select(!c(cty, model))
```

Unlike vector indexing that forbids mixing positive and negative indexing, `select` does allow for it. However, **do not use it**^[Unless you know what you are doing and that is the simplest and clearest way to achieve this.] because results can be fairly counter-intuitive and, on top of that, `-` and `!` work somewhat differently. Note the difference between `!` and `-`: In the former case only the `!model` part appears to have the effect, whereas in case of `-` only `cty` works.
```r
short_mpg %>%
  select(cty, !model)
```
```{r echo=FALSE}
short_mpg %>%
  select(cty, !model) %>%
  knitr::kable()
```

```r
short_mpg %>%
  select(cty, -model)
```
```{r echo=FALSE}
short_mpg %>%
  select(cty, -model) %>%
  knitr::kable()
```

To make things even, worse ` select(-model, cty)` work the same way as  `select(cty, !model)` (sigh...)
```r
short_mpg %>%
  select(-model, cty)
```
```{r echo=FALSE}
short_mpg %>%
  select(-model, cty) %>%
  knitr::kable()
```

So, bottom line, do not mix positive and negative indexing in `select`! I am showing you this only to signal the potential danger.

::: {.infobox .practice}
Do exercise 1.
:::

Simple names and their negation will be sufficient for most of your projects. However, I would recommend taking a look at the [official manual](https://dplyr.tidyverse.org/reference/select.html) just to see that `select` offers a lot of flexibility (selecting by column type, by partial name matching, etc), something that might be useful for you in your later work.

### Conditions {#conditions}
Before we can work with the next verb, you need to understand conditions. Conditions are statements about certain values that are either `TRUE` or `FALSE`. In the simplest case, you can check whether two values (one in a variable and one hard-coded) are equal via `==` operator
```{r}
x <- 5
print(x == 5)
print(x == 3)
```
For numeric values, you can use all usual comparison operators including _not equal_ `!=`, _less than_ `<`, _greater than_ `>`, _less than or equal to_ `<=` (note the order of symbols!), and _greater than or equal to_ `>=` (again, note the order of symbols).

::: {.infobox .practice}
Do exercise 2.
:::

You can negate a statement via _not_ `!` symbol as `!TRUE` is `FALSE` and vice versa. However, note that round brackets in the examples below! They are critical to express the _order_ of computation. Anything _inside_ the brackets is evaluated first. And if you have brackets inside the brackets, similar to nested functions, it is the innermost expression that get evaluated first. In the example below, `x==5` is evaluated first and logical inversion happens only after it. In this particular example, you may not need them but I would suggest using them to ensure clarity.
```{r}
x <- 5
print(!(x == 5))
print(!(x == 3))


```
::: {.infobox .practice}
Do exercise 3.
:::

You can also combine several conditions using _and_ `&` and _or_ `|` operators. Again, note round brackets that explicitly define what is evaluated first.
```{r}
x <- 5
y <- 2

# x is not equal to 5 OR y is equal to 1
print((x != 5) | (y == 1))

# x less than 10 AND y is greater than or equal to 1
print((x < 10) & (y >= 1))
```
::: {.infobox .practice}
Do exercise 4.
:::

All examples above used scalars but you remember that _everything is a vector_, including values that we used (they are just vectors of length one). Accordingly, same logic works for vectors of arbitrary length with comparisons working element-wise, so you get a vector of the same length with `TRUE` or `FALSE` values for each comparison.

::: {.infobox .practice}
Do exercise 4.
:::

## Logical indexing {#logical-indexing}
In the second seminar, you learned about vector indexing when access _some_ elements of a vector by specifying index of elements you are interested in. There is an alternative way, called _logical indexing_, when instead you supply an equal length vector of _logical values_ and you get elements of the original vector whenever the logical value is `TRUE`
```{r}
x <- 1:5
x[c(TRUE, TRUE, FALSE, TRUE, FALSE)]
```


## mutate {#mutate}

