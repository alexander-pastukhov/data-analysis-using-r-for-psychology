# Tidyverse: dplyr {#seminar06}

```{r message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
```


Now that you understand vectors, tables, functions, and pipes, we can start with data analysis and Tidyverse way of doing it in earnest. 

## Tidyverse philosophy
Data analysis is different from "normal" programming as it mostly involves a series of sequential operations on the same table. You might load the table, transform some variables, filter data, select smaller subset of columns, aggregate by summarizing across different groups of variables before plotting it or formally analyzing it via statistical tests. Tidyverse is built around this serial nature of data analysis of piping a table through a chain of functions. Accordingly, Tidyverse functions take a _table_ (`data.frame` or `tibble`) as their _first_ parameter, which makes piping simpler, and return a _modified table_ as an output. This _table-in â†’ table-out_ consistency makes it easy to pipe these operations one after another. For me, it helps to think about Tidyverse functions as _verbs_: Actions that I perform on the table at each step. 

Here is quick teaser of how such sequential piping works. Below, we will examine each verb/function separately and I will also show you how same operations can be carried out using base R. Note that I put each verb/function on a separate line. This makes it easier to understand how many different operations you perform (number of lines), how complex they are (how long individuals lines of code are), and makes them easy to line-by-line. 

```{r}
mpg2lpk <- 2.82481061

mpg %>%
  # we filter the table by rows, 
  # only keeping rows for which year is 2008
  filter(year == 2008) %>%
  
  # we change cty and hwy columns by turning
  # miles/gallon into liters/kilometer
  mutate(cty = cty / mpg2lpk,
         hwy = hwy / mpg2lpk) %>%
  
  # we create a new column by computing an 
  # average efficiency as mean between city and highway cycles
  mutate(avg_mpg = (cty + hwy) / 2) %>%
  
  # we reduce the table to only two columns
  # class (of car) and avg_mpg
  select(class, avg_mpg) %>%
  
  # we group by each class of car
  # and compute average efficiency for each group (class of car)
  group_by(class) %>%
  summarise(class_avg_mpg = mean(avg_mpg), .groups="drop") %>%
  
  # we sort table rows to go from worst to best on efficiency
  arrange(class_avg_mpg) %>%
  
  # we kable (Knit the tABLE) to make it look nicer in the document
  knitr::kable()
```
## dplyr {#dplyr}
All functions discussed below are part of [dplyr](https://dplyr.tidyverse.org/)^[The name should invoke an image of data pliers. According to Hadley Wikham, you can pronounce it any way you like.] "grammar of data manipulation" package.

## mutate {#mutate}

