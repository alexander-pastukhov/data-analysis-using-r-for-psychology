# Factors and Strings {#seminar07}

```{r message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
```

Let us start with a "warm up" exercise that will require combining various things that you already learned. Download [persistence.csv](data/persistence.csv) file (remember, Chrome/Edge browsers may change the extension to _.xls_, just rename it back to _.csv_) and put it into _data_ subfolder in your seminar project folder. This is data from a Master thesis project by Kristina Burkel, published as an article in [Attention, Perception, & Psychophysics](http://link.springer.com/10.3758/s13414-019-01954-7). Grab the [exercise notebook](notebooks/Seminar 07.Rmd) before we start.

## Recap
In the first exercise, I want you to implement the actual analysis performed in the paper.

1. [Load](#readr) the data in a table. Name of the variable is up to you. Typically, I use names like `data`, `reports`, `results`, etc. Don't forget to specify columns' type.
2. Exclude `filename` column (it duplicates `Participant` and `Session` columns).
3. Compute a new variable `SameResponse` which is `TRUE` when `Response1` and `Response2` match each other (in the experiment, that means that an object was rotating in the same direction before and after the intervention).
4. For every combination of `Participant`, `Prime` and `Probe` compute proportion of same responses.
5. Plot the results with `Probe` variable on x-axis, proportion of same responses on y-axis, and use `Prime` to facet plots. Use box plots (or violin plots) to visualize the data. Try adding color, labels, etc. to make plots look nice.

Your final plot should look something like this
```{r echo=FALSE, fig.align='center'}
results <- read_csv("data/persistence.csv", 
                    col_types = cols(filename = col_character(),
                         Participant = col_character(),
                         Session = col_character(),
                         Block = col_double(),
                         Trial = col_double(),
                         OnsetDelay = col_double(),
                         Bias = col_character(),
                         Prime = col_character(),
                         Probe = col_character(),
                         Response1 = col_character(),
                         Response2 = col_character(),
                         RT1 = col_double(),
                         RT2 = col_double()))

results %>%
  select(-filename) %>%
  mutate(SameResponse = Response1 == Response2)  %>%
  group_by(Participant, Prime, Probe) %>%
  summarise(Psame = mean(SameResponse), .groups="drop") %>%
  
  ggplot(aes(x=Probe, y=Psame, color=Probe)) + 
  geom_boxplot() + 
  facet_wrap(.~Prime)
```

::: {.infobox .practice}
Do exercise 1.
:::

When you examine the plot, you can see some sort of non-monotonic dependence with a dip for `"stripes-2"` and `"stripes-4"` objects. In reality, the dependence is monotonic, it is merely the order of values on the x-axis that is wrong. The correct order, based on the area of an object covered with dots, is `"heavy poles sphere"`, `"stripes-8"`, `"stripes-4"`, `"stripes-8"`. Both `Prime` and `Probe` are _ordinal_ variables called _factors_ in R. Thus, to fix the order and to make object names a bit better looking, we must figure out how to work with factors in R. 

## Factors and forcats {#forcats}
Factors are categorical variables, thus variables that have a finite fixed and known set of possible values. They can be either _nominal_ (cannot be ordered) or _ordinal_ (have a specific order to them). An example of the former is the drive train (`drv`) variable in [mpg](https://ggplot2.tidyverse.org/reference/mpg.html) table. There is a finite set of possible values (`"f"` for front-wheel drive, `"r"` for rear wheel drive, and `"4"` for a four-wheel drive) but ordering them makes no sense. An example of an ordinal variable is a Likert scale that has a finite set of possible responses (for example, `"disagree"`, `"neither agree, nor disagree"`, `"agree"`) and they do a fix specific order to them (participant's support for a statement is progressively stronger so that `"disagree"` < `"neither agree, nor disagree"` < `"agree"`).

**Important side-note:** remember, ordinal variables are not metric, so you cannot treat them the same way. For example, you cannot compute a mean response because computation of the mean assumes, among other things, that all factors are equidistant from each other (i.e., `("agree" - "neither agree, nor disagree") == ("neither agree, nor disagree" - "disagree")` and that `2 * ("agree" - "neither agree, nor disagree") == ("agree" - "disagree")`). In reality, most likely this is not the case, particularly when you have more response options (people are typically vary of using extreme values). And, to make things worse, this differences between individual levels will be most probably different for different participants. This issue is not so much about data analysis per se (although, not computing mean response is a good start), but rather about using a correct statistical procedure to analyze ordinal data. If you work with ordinal data (and, if you in psychology then you almost certainly use Likert scale), I strongly recommend reading [Analyzing ordinal data with metric models: What could possibly go wrong?](https://www.sciencedirect.com/science/article/abs/pii/S0022103117307746) paper by Liddell and Kruschke (as of writing, a PDF is freely available at [hbiostat.org](http://hbiostat.org/papers/ordinal/lid18ana.pdf)).


**Another important side-note:** computers are golems, not oracles. Having read the previous paragraph, you may ask yourself: _What if I convert scales to numbers, so that `"disagree"=1`, `"neither agree, nor disagree"=2`, and `"agree"=3` and compute mean of numbers?_. Yep, you can do that! _Will I get some "average" numbers, if I compute mean of these numbers?_ Yes, you will! _Will statistics police knock on my door, if I do that?_ No, it wont! _So, all is good?_ Nope. The fact that computer did not crash and spit out some numbers, does not mean that these numbers mean anything. Computers are [golems](https://en.wikipedia.org/wiki/Golem), not [oracles](https://en.wikipedia.org/wiki/Oracle). They will perform a computation you've asked for even if it makes no sense because they don't know what you are doing and why are you doing it. Computers don't care if you are treating ordinal data as metric or using ANOVA on proportional data. They will carry out the computation and will give the result. Unfortunately, it is _on you_ to know whether results are valid or are even interpretable. The worst case scenario is using a complex analysis without understanding how it actually works and which assumptions it uses. You will have no way of knowing whether your results are valid but might hope that "computer knows what it is doing". This is when you start having a problem because you are flying blind without even realizing that. To summarize, _you_ must know that what you are doing is valid and correct, not the computer!

Now that I've vented my feelings about using inappropiate analysis procedures, let's get back to factors! You can convert _any_ variable to a factor using [factor()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/factor.html) or `as.factor()` functions. The latter is a more limited version of the former, so, below, I will only use `factor()`. When you convert a variable (a vector) to factor, R:

1. figures out all [unique](https://stat.ethz.ch/R-manual/R-devel/library/base/html/unique.html) values in this vector
2. sorts them in an ascending order
3. assigns each value an index ("level")
4. uses the actual value as a "label".

Here is an example of this sequence: there four levels sorted alphabetically.
```{r}
letters <- c("C", "A", "D", "B", "A", "B")
letters_as_factor <- factor(letters)
letters_as_factor
```
You can extracts [levels](https://stat.ethz.ch/R-manual/R-devel/library/base/html/levels.html) of a factor variable by using the function with this name
```{r}
levels(letters_as_factor)
```
You can specify the order of levels either during the `factor()` conversion call or later using [forcats](https://forcats.tidyverse.org/) (more on that later). For example, if we want to have levels in the reverse order we specify it via `levels` parameter. Note the opposite order of levels.
```{r}
letters <- c("C", "A", "D", "B", "A", "B")
letters_as_factor <- factor(letters, levels = c("D", "C", "B", "A"))
letters_as_factor
```
We can also specify `labels` of individual labels instead of using values themselves. Note that labels must
```{r}
responses <- c(1, 3, 2, 2, 1, 3)
responses_as_factor <- factor(responses, labels = c("negative", "neutral", "positive"))
responses_as_factor
```

