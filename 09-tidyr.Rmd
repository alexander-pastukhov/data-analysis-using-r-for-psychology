# Tidyng your data {#seminar09}
It is fun to work with tidy complete data. Unfortunately, more often than not you will need to preprocess and tidy it up before you can process it. Tidyverse has [tidyr](https://tidyr.tidyverse.org/) package that helps you with some of the problems.

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
```

## Pivoting between long and wide format
Recall the idea of [tidy data](#tidydata): 

* variables are in columns,
* observations are in rows,
* values are in cells.

And, also recall, that quite often data is stored in a wide format that is easier for humans read.
```{r echo=FALSE, message=FALSE, warning=FALSE}
widish_df <- 
  tibble(Participant = c(1, 1, 2, 2),
         Face = rep(c("M-1", "M-2"), 2), 
         Symmetry = c(6, 4, 5, 3),
         Attractiveness = c(4, 7, 2, 7),
         Trustworthiness = c(3, 6, 1, 2))

knitr::kable(widish_df, align="c")
```
Here, `Symmetry`, `Attractiveness`, `Trustworthiness` are different face properties participants responded on, whereas values are `Response` they gave. You can work with a table like that but it is often more convenient to have instead a column `Property` that will code which face property participants respond on and a column `Response` to hold values. Then, you can easily split or group your data by property while performing the same analysis on all of them.

The function to do this is [pivot_longer()](https://tidyr.tidyverse.org/reference/pivot_longer.html). It takes a table, which you can pipe  to the function and vector of column names that need to be transformed. All _column names_ go to one new column and all the _values_ go to another new column. Defaults names of these two columns are, respectively, `"name"` and `"value"` but you can specify something more suitable via, respectively, `names_to` and `values_to` parameters. Another

There are many more bells-and-whistles (name and value transformations, removing a prefix via regular expressions, etc.), so recommend looking at the manual and a [vignette](https://tidyr.tidyverse.org/articles/pivot.html). However, in most cases these for parameters will be all you need, so let us see `pivot_longer` in action. 

I assume that table presented above is in `widish_df` table. The columns that we want to transform are  `Symmetry`, `Attractiveness`, `Trustworthiness`. Thus, the simplest call with all defaults is
```r
tidyr::pivot_longer(widish_df, 
                    cols=c("Symmetry", "Attractiveness", "Trustworthiness"))
```
```{r echo=FALSE}
tidyr::pivot_longer(widish_df, 
                    cols=c("Symmetry", "Attractiveness", "Trustworthiness")) %>%
  knitr::kable()
```

When you compare the two tables, you will see that original three columns × four rows are now stretched into twelve rows and name-value pairs are consistent across the two tables^[By the way, this simple math check may seem as a trivial point but this is a kind of simple sanity check that you should perform routinely. This way you _know_ rather than _hope_ that transformation did what it should. I also check value is a few rows to make sure that I didn't mess things up. Catching simple errors early saves you a lot of time!]. As noted above, you can use better names for new columns (I use [head()](https://stat.ethz.ch/R-manual/R-devel/library/utils/html/head.html) function to show only first 4 rows to save space, because data is the same): 
```r
longish_df <- 
  tidyr::pivot_longer(widish_df, 
                      cols=c("Symmetry", "Attractiveness", "Trustworthiness"),
                      names_to="Property",
                      values_to="Response")
                      
head(longish_df, 4)
```
```{r echo=FALSE}
longish_df <- 
  tidyr::pivot_longer(widish_df, 
                      cols=c("Symmetry", "Attractiveness", "Trustworthiness"),
                      names_to="Property",
                      values_to="Response")

head(longish_df, 4) %>%
  knitr::kable()
```

You also can go from long to wide representation via [pivot_wider()](https://tidyr.tidyverse.org/reference/pivot_wider.html) function. The logic is reverse, you need to specify which columns _identify_ different rows that belong together (that one is optional), which columns contain column names and which contain their values. For our example table the names of the columns are in the column `Property` and values are in `Response`. But what about columns that identify the rows that belong together? In our case, these are `Participant` and `Face`, so all rows from a _long_ table that have same combination of `Participant` and `Face` values should be merged together into a single row. If you do not explicitly specify `id_cols`, then by default, _all other remaining columns_ are used to identify which rows belong together. This is irrelevant in this toy example, as `Participant` and `Face` is all we have left anyhow but I will show you how things can get confusing and how to overcome this below.

So, let us undo our previous wide-to-long transformation^[I used table as an explicit first argument for `pivot_longer()` but piped it to `pivot_wider()`, why? To remind you that these two ways are the interchangeable and that both put the table as a parameter into the function.]
```r
longish_df %>%
  pivot_wider(names_from = "Property", values_from="Response")
```
```{r echo=FALSE}
longish_df %>%
  pivot_wider(id_cols = c("Participant", "Face"), names_from = "Property", values_from="Response") %>%
  knitr::kable()
```

And our original wide table is back! 

Now let us take a look at the importance of `id_cols`. Imagine that we have _another_ column, say, response times. So, our long table will look like this
```{r echo=FALSE}
longish_df_rt <-
  longish_df %>%
  ungroup() %>%
  mutate(RT = round(rgamma(n(), 4, 3), 2))

longish_df_rt %>%
  head(4) %>%
  knitr::kable()
```
Now, if we do not specify which columns identify rows that belong together, `RT` will be used as well. But, because it is different for every response, each row in the original table will be unique. Now we have a weird looking table

```r
longish_df_rt %>%
  pivot_wider(names_from = "Property", values_from="Response")
```
```{r}
longish_df_rt %>%
  pivot_wider(names_from = "Property", values_from="Response") %>%
  head(4) %>%
  knitr::kable()
```


To remedy that, we need to specify id columns explicitly, so that `pivot_wider()` can ignore and drop the rest:
```r
longish_df_rt %>%
  pivot_wider(id_cols = c("Participant", "Face"), names_from = "Property", values_from="Response")
```
```{r}
longish_df_rt %>%
  pivot_wider(id_cols = c("Participant", "Face"), names_from = "Property", values_from="Response") %>%
  head(4) %>%
  knitr::kable()
```

As `pivot_longer`, `pivot_wider` has plenty of parameters to fine-tune pivoting, so you should check them to know what it can do.

## Practice pivoting longer
Let us put this new knowledge to practice, using [GP.csv](data/GP.csv) file. These is a questionnaire on gaming habits, which was conducted prior to an experiment to check whether two groups of participants assigned to _Game_ and _Experiment_ conditions have similar gaming habits. We would like to visually inspect responses to individual items in a questionnaire appear for different conditions, as this will tell us whether we should expect a difference. Split the computations below into two pipelines. One that loads and pre-processes the data (steps 1-3). Another one that produces a summary and stores it into a different table (step 4). Advice, implement it one step at a time, checking the table and making sure that you get expected results before piping it and adding the next operation.

1. Read the file, make sure you specify column types.
2. Convert `Condition` column to a factor with `1` corresponding to `"Game"` and `2` to `"Exp"`.
3. Pivot all `GP..` columns. You should get a table with five columns: `Respondent`, `Condition`, `Gender`, `name` (or a column name that you specified), and `value` (or a column name that you specified). Hint, you can use slicing `:` to specify the range of columns or [starts_with()](https://tidyselect.r-lib.org/reference/starts_with.html) function to specify a common prefix. Try both approaches.
4. Group data by condition and GP item and compute median and [median absolute deviation](https://stat.ethz.ch/R-manual/R-devel/library/stats/html/mad.html) of responses. These are robust versions of mean and standard deviation, better suitable for data with potential outliers.

You first table, in long format, should look like this (I show only first four rows)
```{r echo=FALSE, fig.align='center'}
gp <-
  read_csv("data/GP.csv", 
           col_types = cols(.default=col_integer(),
                            Respondent = col_character(),
                            Condition = col_integer(),
                            Gender = col_integer())) %>%
  mutate(Condition = factor(Condition, labels=c("Game", "Exp"))) %>%
  pivot_longer(cols=starts_with("GP"), names_to="Item", values_to="Response")

head(gp, 4) %>%
  knitr::kable()  
```
And your second table, with aggregated results, show be like this

```{r echo=FALSE}
gp_agg <-
  gp %>%
  group_by(Condition, Item) %>%
  summarise(MedianResponse = median(Response),
            ResponseMAD = mad(Response),
            .groups="drop")

head(gp_agg, 4) %>%
  knitr::kable()
```

Now you have a table that has median and MAD values for each combination and item. Plot them to compare them visually. Use median responses for y-value of points and median±MAD for error bars. Use facets and color to make it easier to identify the items and conditions. My take on the plot is below, do you think we should expect to find difference between the conditions?
```{r echo=FALSE, fig.align='center'}
ggplot(gp_agg, aes(x=Condition, y=MedianResponse, ymin=MedianResponse - ResponseMAD, ymax=MedianResponse+ResponseMAD, color=Condition)) + 
  geom_point() + 
  geom_errorbar() +
  facet_wrap(.~Item, ncol=6)
```

::: {.infobox .practice}
Do exercise 1.
:::

Perform similar analysis but do not group data and summarize the data. Instead, use box plots to show the variability. Which visualization do you prefer?

```{r echo=FALSE, fig.align='center'}
ggplot(gp, aes(x=Condition, y=Response, color=Condition)) + 
  geom_boxplot() + 
  facet_wrap(.~Item, ncol=6)
```

::: {.infobox .practice}
Do exercise 2.
:::

## Practice pivoting wider

Let us take [adaptation](data/bands-adaptation.csv) data and turn it onto a wide format that is easier for humans to read. In the original form, the table is a long format with a row for each pair of prime and probe stimuli.

```{r echo=FALSE}
adaptation <- 
  read_csv("data/bands-adaptation.csv",
           col_types = cols(Participant = col_character(),
                            Prime = col_character(),
                            Probe = col_character(),
                            Nsame = col_integer(),
                            Ntotal = col_integer()))

adaptation %>% 
  head(4) %>%
  knitr::kable()
```

Let us turn it into a wider table, so that a single row corresponds to a single prime and four new column contain proportion of same responses for individual probes. The table will look like this (use [round()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Round.html) function to reduce the number of digits):

```{r echo=FALSE}
adaptation %>%
  mutate(Psame = round(Nsame / Ntotal, 2)) %>%
  pivot_wider(id_cols = c("Participant", "Prime"), names_from="Probe", values_from="Psame") %>%
  mutate(Average = rowSums(.[3:6]) / 4) %>%
  head(4) %>%
  knitr::kable()
```

The overall procedure is very straightforward:

1. Read the file (don't forget to specify column types)
2. Computer `Psame` proportion of same responses given number of total responses.
3. Pivot the table wider, think about your id columns. Also try without specifying any and see what you get.
4. Compute an average stability across all probes and put it into a new `Average` column. You can do it "by hand" but, instead, use [rowSums()](https://stat.ethz.ch/R-manual/R-devel/library/base/html/colSums.html) to compute it. Here, use `.` to refer to the table inside the `mutate()` function and you will need to normalize it by the number of probes to get an average instead of the sum.
5. Pipe it to the output, using [knitr::kable()](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html).

::: {.infobox .practice}
Do exercise 3.
:::

## Separate string into several columns

